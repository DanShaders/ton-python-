import struct
from collections import defaultdict
from pathlib import Path
from zlib import crc32

from ..sourcebuilder import SourceBuilder
from ..utils import get_class_name
from ..parsers.tlobject import ParsedTLObject, TLArg

AUTO_GEN_NOTICE = '"""FILE IS AUTOGENERATED"""'


BASE_TYPES = ('string', 'bytes', 'int', 'long', 'int128',
              'int256', 'int64', 'int32', 'int53', 'double', 'Bool', 'true')


def _write_modules(out_file: Path, kind: str, tlobjects: list[ParsedTLObject], type_constructors: dict[str, list[ParsedTLObject]]):
    out_file.parent.mkdir(parents=True, exist_ok=True)
    with out_file.open('w') as f, SourceBuilder(f) as builder:
        builder.writeln(AUTO_GEN_NOTICE)

        builder.writeln('from tl.tlobject import TLObject')
        builder.writeln('T = TLObject')
        if kind != 'TLObject':
            builder.writeln(
                f'from tl.tlobject import {kind}')

        builder.writeln('from typing import TYPE_CHECKING, Any, override, cast')

        # Import struct for the .__bytes__(self) serialization
        builder.writeln('import struct')
        builder.writeln('import base64')
        builder.writeln('if TYPE_CHECKING:')
        builder.writeln('from tl.tlobject import BinaryReader')
        builder.current_indent -= 1

        tlobjects.sort(key=lambda x: x.name)

        type_names: set[str] = set()
        type_defs: list[str] = []

        for t in tlobjects:
            if not t.is_function:
                type_name = get_class_name(t.result)
                if type_name in type_names:
                    continue
                type_names.add(type_name)
                constructors = type_constructors[t.result]
                if not constructors:
                    pass
                elif len(constructors) == 1:
                    type_defs.append('type Type{} = {}'.format(
                        type_name, constructors[0].class_name))
                else:
                    type_defs.append(f'type Type{type_name} = {' | '.join(c.class_name for c in constructors)}')

        imports: set[str] = set()
        primitives = {'int', 'long', 'int128', 'int256', 'int64', 'int32', 'int53', 'double',
                      'string', 'date', 'bytes', 'Bool', 'true'}
        # Find all the types in other files that are used in this file
        # and generate the information required to import those types.
        for t in tlobjects:
            if not t.is_function:
                continue
            for arg in t.args:
                name = arg.type
                if not name or name in primitives:
                    continue
                name = arg.get_type_class_name()
                if not arg.skip_constructor_id:
                    name = 'Type' + name
                if name not in type_names:
                    type_names.add(name)
                    imports.add(name)

        if imports:
            write_imports(', '.join(sorted(imports)), builder, type_checking=True)

        # Generate the class for every TLObject
        for t in tlobjects:
            _write_source_code(t, kind, builder, type_constructors, out_file)
            builder.current_indent = 0

        # Write the type definitions generated earlier.
        builder.writeln()
        for line in type_defs:
            builder.writeln(line)


def _write_source_code(tlobject: ParsedTLObject, kind: str, builder: SourceBuilder, type_constructors: dict[str, list[ParsedTLObject]], filename: Path):
    """
    Writes the source code corresponding to the given TLObject
    by making use of the ``builder`` `SourceBuilder`.

    Additional information such as file path depth and
    the ``Type: [Constructors]`` must be given for proper
    importing and documentation strings.
    """
    _write_class_init(tlobject, kind, type_constructors, builder)
    _write_to_dict(tlobject, builder)
    _write_from_dict(tlobject, type_constructors, builder)
    _write_to_bytes(tlobject, builder)
    _write_from_reader(tlobject, builder, filename)
    # _write_read_result(tlobject, builder)


def _write_class_init(tlobject: ParsedTLObject, kind: str, type_constructors: dict[str, list[ParsedTLObject]], builder: SourceBuilder):
    builder.writeln()
    builder.writeln()
    builder.writeln('class {}({}):', tlobject.class_name, kind)

    # Class-level variable to store its Telegram's constructor ID
    builder.writeln('CONSTRUCTOR_ID: int = {:#x}'.format(tlobject.id))
    builder.writeln('SUBCLASS_OF_ID: int = {:#x}'.format(crc32(tlobject.result.encode('ascii'))))
    builder.writeln()

    # Convert the args to string parameters, those with flag having =None
    args = ['{}: {}{}'.format(
        a.name + '_', a.type_hint(), '=None' if a.flag else '')
        for a in tlobject.real_args
    ]

    # Write the __init__ function if it has any argument
    if not tlobject.real_args:
        return

    builder.writeln("def __init__({}):", ', '.join(['self'] + args))
    builder.writeln('"""')
    if tlobject.is_function:
        builder.write(':returns {}: ', tlobject.result)
    else:
        builder.write('Constructor for {}: ', tlobject.result)

    constructors = type_constructors[tlobject.result]
    if not constructors:
        builder.writeln('This type has no constructors.')
    elif len(constructors) == 1:
        builder.writeln('Instance of {}.',
                        constructors[0].class_name)
    else:
        builder.writeln('Instance of either {}.', ', '.join(
            c.class_name for c in constructors))
    builder.writeln(str(tlobject))
    builder.writeln('"""')

    # Set the arguments
    for arg in tlobject.real_args:
        builder.writeln(arg.get_init_arg(arg.name + '_'))
        # builder.writeln('self.{0} = {0}', arg.name)

    builder.end_block()



def _write_to_dict(tlobject: ParsedTLObject, builder: SourceBuilder):
    builder.writeln('@override')
    builder.writeln('def to_dict(self) -> dict[str, Any]: # pyright: ignore[reportExplicitAny]')
    builder.current_indent += 1
    builder.writeln('return {')
    builder.current_indent += 1

    builder.write("'@type': '{}'", tlobject.fullname)
    for arg in tlobject.real_args:
        builder.writeln(',')
        if arg.type in BASE_TYPES:
            builder.write(f"'{arg.name}': ")
            if arg.is_vector:
                builder.write('[] if not self.{0} else self.{0}[:]',
                              arg.name)
            else:
                builder.write('self.{}', arg.name)
        else:
            if arg.is_vector:
                builder.write(f"'{arg.name}': ")
                builder.write(
                    f'[] if not self.{arg.name} else [x.to_dict() ' +
                    f'if isinstance(x, TLObject) else x for x in self.{arg.name}]'
                )
            else:
                builder.write(
                    f"**({{'{arg.name}': self.{arg.name}.to_dict()}} " +
                    f"if self.{arg.name} is not None else {{}})"
                )  # do not write object in json if it's None

    builder.writeln()
    builder.current_indent -= 1
    builder.writeln("}")

    builder.end_block()

def write_imports(names: str, builder: SourceBuilder, type_checking: bool = False):
    if type_checking:
        builder.writeln('if TYPE_CHECKING:')
    builder.writeln(f'from .types import {names}' )
    if type_checking:
        builder.end_block()

def get_from_dict(arg: TLArg):
    if not arg.is_vector:
        return f'cast(dict[str, object], d["{arg.name}"])'
    return f'cast(list[dict[str, object]], d["{arg.name}"])'

def _write_from_dict(tlobject: ParsedTLObject, type_constructors: dict[str, list[ParsedTLObject]], builder: SourceBuilder):
    builder.writeln('@classmethod')
    builder.writeln('@override')
    builder.writeln('def from_dict(cls, d: dict[str, Any]):  # pyright: ignore[reportExplicitAny]')
    builder.current_indent += 1
    builder.writeln(f'assert isinstance(d, dict)')
    builder.writeln(f'assert d.get("@type") == "{tlobject.fullname}"')

    for arg in tlobject.args:
        arg_name = '_' + arg.name.lower()

        if arg.type in BASE_TYPES:
            builder.writeln(f'{arg_name}: {arg.type_hint()} = cast({arg.type_hint()}, d.get("{arg.name}", {arg.default_value()}))')
        else:

            builder.writeln(f'if "{arg.name}" not in d:')
            builder.writeln(f'{arg_name} = {arg.default_value()}')
            builder.current_indent -= 1
            builder.writeln('else:')

            name = arg.get_type_class_name()
            constructors = type_constructors.get(arg.type, [])

            s = f'{arg_name}: {arg.type_hint()} = '

            if not arg.skip_constructor_id:
                class_names = [n.class_name for n in constructors]
                full_names = [n.fullname for n in constructors]
                if tlobject.is_function:
                    write_imports(', '.join(class_names), builder)

                if arg.is_vector:
                    s += f'[] if d["{arg.name}"] is None else ['
                    for c, f in zip(class_names, full_names):
                        s += f' {c}.from_dict(x) if x["@type"] == "{f}" else'
                    s += f' None for x in {get_from_dict(arg)}]'
                else:
                    for c, f in zip(class_names, full_names):
                        s += f' {c}.from_dict({get_from_dict(arg)}) if d["{arg.name}"]["@type"] == "{f}" else'
                    s += f' None'
                builder.writeln(s)
            else:
                if tlobject.is_function:
                    write_imports(name, builder)
                if not arg.is_vector:
                    builder.writeln(
                        f'{s} {name}.from_dict({get_from_dict(arg)}) ' +
                        f'if isinstance(d["{arg.name}"], dict) else None'
                    )
                else:
                    builder.writeln(
                        f'{s} [] if not {get_from_dict(arg)} else [{name}.from_dict(x) for x in {get_from_dict(arg)}]',
                    )
            builder.current_indent -= 1

    builder.writeln('return cls({})', ', '.join(
        '{0}_=_{1}'.format(a.name, a.name.lower()) for a in tlobject.real_args))

    builder.end_block()


def _write_to_bytes(tlobject: ParsedTLObject, builder: SourceBuilder):
    builder.writeln('@override')
    builder.writeln('def to_bytes(self) -> bytes:')

    # Some objects require more than one flag parameter to be set
    # at the same time. In this case, add an assertion.
    repeated_args: dict[tuple[str, int], list[TLArg]] = defaultdict(list)
    for arg in tlobject.args:
        if arg.flag:
            repeated_args[(arg.flag, arg.flag_index)].append(arg)

    for ra in repeated_args.values():
        if len(ra) > 1:
            cnd1 = ('(self.{0} or self.{0} is not None)'
                    .format(a.name) for a in ra)
            cnd2 = ('(self.{0} is None or self.{0} is False)'
                    .format(a.name) for a in ra)
            builder.writeln(
                "assert ({}) or ({}), '{} parameters must all " +
                "be False-y (like None) or all me True-y'",
                ' and '.join(cnd1), ' and '.join(cnd2),
                ', '.join(a.name for a in ra)
            )

    builder.writeln("return b''.join((")
    builder.current_indent += 1

    # First constructor code, we already know its bytes
    builder.writeln('{},', repr(struct.pack('<I', tlobject.id)))

    for arg in tlobject.args:
        if _write_arg_to_bytes(builder, arg, tlobject):
            builder.writeln(',')

    builder.current_indent -= 1
    builder.writeln('))')
    builder.end_block()


def _write_from_reader(tlobject: ParsedTLObject, builder: SourceBuilder, filename: Path):
    builder.writeln('@classmethod')
    builder.writeln('@override')
    builder.writeln("def from_reader(cls, reader: 'BinaryReader'):")
    for arg in tlobject.args:
        _write_arg_read_code(builder, arg, tlobject, name='_' + arg.name.lower(), filename=filename)

    builder.writeln('return cls({})', ', '.join(
        '{0}_=_{1}'.format(a.name, a.name.lower()) for a in tlobject.real_args))


def _write_arg_to_bytes(builder: SourceBuilder, arg: TLArg, tlobject: ParsedTLObject, name: str | None = None):
    """
    Writes the .__bytes__() code for the given argument
    :param builder: The source code builder
    :param arg: The argument to write
    :param tlobject: The parent TLObject
    :param name: The name of the argument. Defaults to "self.argname"
                 This argument is an option because it's required when
                 writing Vectors<>
    """
    if arg.generic_definition:
        return  # Do nothing, this only specifies a later type

    if name is None:
        name = 'self.{}'.format(arg.name)

    # The argument may be a flag, only write if it's not None AND
    # if it's not a True type.
    # True types are not actually sent, but instead only used to
    # determine the flags.
    if arg.flag:
        if arg.type == 'true':
            return  # Exit, since True type is never written
        elif arg.is_vector:
            # Vector flags are special since they consist of 3 values,
            # so we need an extra join here. Note that empty vector flags
            # should NOT be sent either!
            builder.write("b'' if {0} is None " +
                          "else b''.join((", name)
        elif 'Bool' == arg.type:
            # `False` is a valid value for this type, so only check for `None`.
            builder.write("b'' if {0} is None else (", name)
        else:
            builder.write("b'' if {0} is None " +
                          "else (", name)

    if arg.is_vector:
        if arg.use_vector_id:
            # vector code, unsigned 0x1cb5c415 as little endian
            builder.write(r"b'\x15\xc4\xb5\x1c',")

        builder.write("struct.pack('<i', len({})),", name)

        # Cannot unpack the values for the outer tuple through *[(
        # since that's a Python >3.5 feature, so add another join.
        builder.write("b''.join(")

        # Temporary disable .is_vector, not to enter this if again
        # Also disable .flag since it's not needed per element
        old_flag, arg.flag = arg.flag, None
        arg.is_vector = False
        _ = _write_arg_to_bytes(builder, arg, tlobject, name='x')
        arg.is_vector = True
        arg.flag = old_flag

        builder.write(' for x in {})', name)

    elif arg.flag_indicator:
        # Calculate the flags with those items which are not None
        if not any(f.flag for f in tlobject.args):
            # There's a flag indicator, but no flag arguments so it's 0
            builder.write(r"b'\0\0\0\0'")
        else:
            def fmt_flag_arg(a: TLArg):
                if a.type == 'Bool':
                    fmt = '(0 if {0} is None else {1})'
                else:
                    fmt = '(0 if {0} is None or {0} else {1})'
                return fmt.format(f'self.{a.name}', str(1 << a.flag_index))

            builder.write("struct.pack('<I', ")
            builder.write(
                ' | '.join(fmt_flag_arg(a) for a in tlobject.args if a.flag == arg.name)
            )
            builder.write(')')

    elif arg.type in ('int', 'int32'):
        builder.write("struct.pack('<i', {})", name)

    elif arg.type in ('long', 'int64', 'int53'):
        builder.write("struct.pack('<q', {})", name)

    elif 'int128' == arg.type:
        # builder.write("{}.to_bytes(16, 'little', signed=True)", name)
        builder.write(f"{name}[::-1]", name)

    elif 'int256' == arg.type:
        # builder.write("{}.to_bytes(32, 'little', signed=True)", name)
        builder.write(f"{name}[::-1]", name)

    elif 'double' == arg.type:
        builder.write("struct.pack('<d', {})", name)

    elif 'string' == arg.type:
        builder.write('self.serialize_bytes({})', name)

    elif 'Bool' == arg.type:
        # 0x997275b5 if boolean else 0xbc799737
        builder.write(r"b'\xb5ur\x99' if {} else b'7\x97y\xbc'", name)

    elif 'true' == arg.type:
        pass  # These are actually NOT written! Only used for flags

    elif 'bytes' == arg.type:
        builder.write('self.serialize_bytes({})', name)

    else:
        # Else it may be a custom type
        if not arg.flag:
            builder.write(f'({name}.to_bytes() if {name} is not None else b"")')
        else:
            builder.write(f'{name}.to_bytes()')

        # If the type is not boxed (i.e. starts with lowercase) we should
        # not serialize the constructor ID (so remove its first 4 bytes).
        boxed = arg.type[arg.type.find('.') + 1].isupper()
        if not boxed:
            builder.write('[4:]')

    if arg.flag:
        builder.write(')')
        if arg.is_vector:
            builder.write(')')  # We were using a tuple

    return True  # Something was written


def _write_arg_read_code(builder: SourceBuilder, arg: TLArg, tlobject: ParsedTLObject, name: str, filename: Path):

    if arg.generic_definition:
        return  # Do nothing, this only specifies a later type

    # The argument may be a flag, only write that flag was given!
    old_flag = None
    builder.writeln(f'{name}: {arg.type_hint()}')
    if arg.flag:
        # Treat 'true' flags as a special case, since they're true if
        # they're set, and nothing else needs to actually be read.
        if 'true' == arg.type:
            builder.writeln('{} = bool({} & {})',
                            name, '_' + arg.flag, str(1 << arg.flag_index))
            return

        builder.writeln('if {} & {}:','_' +  arg.flag, str(1 << arg.flag_index))
        # Temporary disable .flag not to enter this if
        # again when calling the method recursively
        old_flag, arg.flag = arg.flag, None

    if arg.is_vector:
        if arg.use_vector_id:
            # We have to read the vector's constructor ID
            builder.writeln("_ = reader.read_int()")

        builder.writeln(f'{name} = []')
        # builder.writeln(f'{name}: {arg.type_hint()} = []')
        builder.writeln('for _ in range(reader.read_int()):')
        # Temporary disable .is_vector, not to enter this if again
        arg.is_vector = False
        _write_arg_read_code(builder, arg, tlobject, name=f'_{name}', filename=filename)
        builder.writeln(f"{name}.append(_{name})")
        arg.is_vector = True

    elif arg.flag_indicator:
        # Read the flags, which will indicate what items we should read next
        # builder.writeln('{} = reader.read_int()', arg.name)
        builder.writeln('{} = reader.read_int()', name)
        builder.writeln()

    elif arg.type in ('int', 'int32'):
        builder.writeln('{} = reader.read_int()', name)

    elif arg.type in ('long', 'int64', 'int53'):
        builder.writeln('{} = reader.read_long()', name)

    elif 'int128' == arg.type:
        # builder.writeln('{} = reader.read_large_int(bits=128)', name)
        builder.writeln('{} = reader.read_bytes(16)', name)

    elif 'int256' == arg.type:
        # builder.writeln('{} = reader.read_large_int(bits=256)', name)
        builder.writeln('{} = reader.read_bytes(32)', name)

    elif 'double' == arg.type:
        builder.writeln('{} = reader.read_double()', name)

    elif 'string' == arg.type:
        builder.writeln('{} = reader.tgread_string()', name)

    elif 'Bool' == arg.type:
        builder.writeln('{} = reader.tgread_bool()', name)

    elif 'true' == arg.type:
        # Arbitrary not-None value, don't actually read "true" flags
        builder.writeln('{} = True', name)

    elif 'bytes' == arg.type:
        builder.writeln('{} = reader.tgread_bytes()', name)

    else:
        # Else it may be a custom type
        if not arg.skip_constructor_id:
            builder.writeln(f'{name} = cast({arg.type_hint()}, reader.tgread_object())')
        else:

            class_name = arg.get_type_class_name()

            if tlobject.is_function:
                write_imports(class_name, builder)
            builder.writeln(f'{name}= {class_name}.from_reader(reader)')

    # End vector and flag blocks if required (if we opened them before)
    if arg.is_vector:
        builder.end_block()

    if old_flag:
        builder.current_indent -= 1
        builder.writeln('else:')
        # Restore .flag
        arg.flag = old_flag
        builder.writeln(f'{name} = None')
        builder.current_indent -= 1


def _write_all_tlobjects(tlobjects: list[ParsedTLObject], builder: SourceBuilder):
    builder.writeln(AUTO_GEN_NOTICE)
    builder.writeln()

    builder.writeln('from . import types, functions')
    builder.writeln()

    builder.writeln('tlobjects = {')
    builder.current_indent += 1

    # Fill the dictionary (0x1a2b3c4f: tl.full.type.path.Class)
    tlobjects.sort(key=lambda x: x.name)
    for tlobject in tlobjects:
        builder.write('{:#010x}: '.format(tlobject.id))
        builder.write('functions' if tlobject.is_function else 'types')


        builder.writeln('.{},', tlobject.class_name)

    builder.current_indent -= 1
    builder.writeln('}')


def sort_tlobjects(tlobjects: list[ParsedTLObject]) -> tuple[list[ParsedTLObject], list[ParsedTLObject], dict[str, list[ParsedTLObject]]]:
    functions: list[ParsedTLObject] = []
    types: list[ParsedTLObject] = []
    type_constructors: dict[str, list[ParsedTLObject]] = defaultdict(list)
    for tlobject in tlobjects:
        if tlobject.is_function:
            functions.append(tlobject)
        else:
            types.append(tlobject)
            type_constructors[tlobject.result].append(tlobject)
    return functions, types, type_constructors


def generate_tlobjects(tlobjects: list[ParsedTLObject], fn: str, output_dir: Path):
    functions, types, type_constructors = sort_tlobjects(tlobjects)
    _write_modules(output_dir / fn / 'functions.py', 'TLRequest',
                   functions, type_constructors)
    _write_modules(output_dir / fn / 'types.py', 'TLObject',
                   types, type_constructors)

    filename = output_dir / fn / 'alltlobjects.py'
    with filename.open('w') as file:
        with SourceBuilder(file) as builder:
            _write_all_tlobjects(tlobjects, builder)
